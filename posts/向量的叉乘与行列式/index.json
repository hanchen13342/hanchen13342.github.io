[{"content":"友情链接\r\rSharpFactory\nSharpFactory 官网\r\r\r\rKuboard\nxurenda | 朽者，然也\r\r\r\rKuboard\n陈煜峰个人博客\r\r\r\r","description":"云原生实验室的友情链接","id":2,"section":"","tags":null,"title":"我的朋友们","uri":"https://SJiaman.github.io/friends/"},{"content":"书接前文，上文我们通过跟踪集群外通过 ingressgateway 发起的请求来探寻流量在 Istio 服务网格之间的流动方向，先部署 bookinfo 示例应用，然后创建一个监听在 ingressgateway 上的 GateWay 和 VirtualService，通过分析我们追踪到请求最后转交给了 productpage。\n在继续追踪请求之前，先对之前的内容做一个补充说明。\n1. Pod 在服务网格之间如何通信？ 大家都知道，在 Istio 尚未出现之前，Kubernetes 集群内部 Pod 之间是通过 ClusterIP 来进行通信的，那么通过 Istio 在 Pod 内部插入了 Sidecar 之后，微服务应用之间是否仍然还是通过 ClusterIP 来通信呢？我们来一探究竟！\n继续拿上文的步骤举例子，来看一下 ingressgateway 和 productpage 之间如何通信，请求通过 ingressgateway 到达了 endpoint ，那么这个 endpoint 到底是 ClusterIP + Port 还是 PodIP + Port 呢？由于 istioctl 没有提供 eds 的查看参数，可以通过 pilot 的 xds debug 接口来查看：\n# 获取 istio-pilot 的 ClusterIP $ export PILOT_SVC_IP=$(kubectl -n istio-system get svc -l app=istio-pilot -o go-template=\u0026#39;{{range .items}}{{.spec.clusterIP}}{{end}}\u0026#39;) # 查看 eds $ curl http://$PILOT_SVC_IP:8080/debug/edsz|grep \u0026#34;outbound|9080||productpage.default.svc.cluster.local\u0026#34; -A 27 -B 1 { \u0026#34;clusterName\u0026#34;: \u0026#34;outbound|9080||productpage.default.svc.cluster.local\u0026#34;, \u0026#34;endpoints\u0026#34;: [ { \u0026#34;lbEndpoints\u0026#34;: [ { \u0026#34;endpoint\u0026#34;: { \u0026#34;address\u0026#34;: { \u0026#34;socketAddress\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;172.30.135.40\u0026#34;, \u0026#34;portValue\u0026#34;: 9080 } } }, \u0026#34;metadata\u0026#34;: { \u0026#34;filterMetadata\u0026#34;: { \u0026#34;istio\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;kubernetes://productpage-v1-76474f6fb7-pmglr.default\u0026#34; } } } } ] } ] }, 从这里可以看出，各个微服务之间是直接通过 PodIP + Port 来通信的，Service 只是做一个逻辑关联用来定位 Pod，实际通信的时候并没有通过 Service。\n2. 部署 bookinfo 应用的时候发生了什么？ 通过 Istio 来部署 bookinfo 示例应用时，Istio 会向应用程序的所有 Pod 中注入 Envoy 容器。但是我们仍然还不清楚注入的 Envoy 容器的配置文件里都有哪些东西，这时候就是 istioctl 命令行工具发挥强大功效的时候了，可以通过 proxy-config 参数来深度解析 Envoy 的配置文件（上一节我们已经使用过了）。\n我们先把目光锁定在某一个固定的 Pod 上，以 productpage 为例。先查看 productpage 的 Pod Name：\n$ kubectl get pod -l app=productpage NAME READY STATUS RESTARTS AGE productpage-v1-76474f6fb7-pmglr 2/2 Running 0 7h 1. 查看 productpage 的监听器的基本基本摘要\n$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr ADDRESS PORT TYPE 172.30.135.40 9080 HTTP // ③ Receives all inbound traffic on 9080 from listener `0.0.0.0_15001` 10.254.223.255 15011 TCP \u0026lt;---+ 10.254.85.22 20001 TCP | 10.254.149.167 443 TCP | 10.254.14.157 42422 TCP | 10.254.238.17 9090 TCP | ② Receives outbound non-HTTP traffic for relevant IP:PORT pair from listener `0.0.0.0_15001` 10.254.184.32 5556 TCP | 10.254.0.1 443 TCP | 10.254.52.199 8080 TCP | 10.254.118.224 443 TCP \u0026lt;---+ 0.0.0.0 15031 HTTP \u0026lt;--+ 0.0.0.0 15004 HTTP | 0.0.0.0 9093 HTTP | 0.0.0.0 15030 HTTP | 0.0.0.0 8080 HTTP | ④ Receives outbound HTTP traffic for relevant port from listener `0.0.0.0_15001` 0.0.0.0 8086 HTTP | 0.0.0.0 9080 HTTP | 0.0.0.0 15010 HTTP \u0026lt;--+ 0.0.0.0 15001 TCP // ① Receives all inbound and outbound traffic to the pod from IP tables and hands over to virtual listener Istio 会生成以下的监听器：\n ① 0.0.0.0:15001 上的监听器接收进出 Pod 的所有流量，然后将请求移交给虚拟监听器。 ② 每个 Service IP 配置一个虚拟监听器，每个出站 TCP/HTTPS 流量一个非 HTTP 监听器。 ③ 每个 Pod 入站流量暴露的端口配置一个虚拟监听器。 ④ 每个出站 HTTP 流量的 HTTP 0.0.0.0 端口配置一个虚拟监听器。  上一节提到服务网格之间的应用是直接通过 PodIP 来进行通信的，但还不知道服务网格内的应用与服务网格外的应用是如何通信的。大家应该可以猜到，这个秘密就隐藏在 Service IP 的虚拟监听器中，以 kube-dns 为例，查看 productpage 如何与 kube-dns 进行通信：\n$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr --address 10.254.0.2 --port 53 -o json [ { \u0026#34;name\u0026#34;: \u0026#34;10.254.0.2_53\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;socketAddress\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;10.254.0.2\u0026#34;, \u0026#34;portValue\u0026#34;: 53 } }, \u0026#34;filterChains\u0026#34;: [ { \u0026#34;filters\u0026#34;: [ ... { \u0026#34;name\u0026#34;: \u0026#34;envoy.tcp_proxy\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;cluster\u0026#34;: \u0026#34;outbound|53||kube-dns.kube-system.svc.cluster.local\u0026#34;, \u0026#34;stat_prefix\u0026#34;: \u0026#34;outbound|53||kube-dns.kube-system.svc.cluster.local\u0026#34; } } ] } ], \u0026#34;deprecatedV1\u0026#34;: { \u0026#34;bindToPort\u0026#34;: false } } ] # 查看 eds $ curl http://$PILOT_SVC_IP:8080/debug/edsz|grep \u0026#34;outbound|53||kube-dns.kube-system.svc.cluster.local\u0026#34; -A 27 -B 1 { \u0026#34;clusterName\u0026#34;: \u0026#34;outbound|53||kube-dns.kube-system.svc.cluster.local\u0026#34;, \u0026#34;endpoints\u0026#34;: [ { \u0026#34;lbEndpoints\u0026#34;: [ { \u0026#34;endpoint\u0026#34;: { \u0026#34;address\u0026#34;: { \u0026#34;socketAddress\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;172.30.135.21\u0026#34;, \u0026#34;portValue\u0026#34;: 53 } } }, \u0026#34;metadata\u0026#34;: { \u0026#34;filterMetadata\u0026#34;: { \u0026#34;istio\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;kubernetes://coredns-64b597b598-4rstj.kube-system\u0026#34; } } } } ] }, 可以看出，服务网格内的应用仍然通过 ClusterIP 与网格外的应用通信，但有一点需要注意 :** 这里并没有 kube-proxy 的参与！**Envoy 自己实现了一套流量转发机制，当你访问 ClusterIP 时，Envoy 就把流量转发到具体的 Pod 上去，**不需要借助 kube-proxy 的 iptables 或 ipvs 规则**。\n2. 从上面的摘要中可以看出，每个 Sidecar 都有一个绑定到 0.0.0.0:15001 的监听器，IP tables 将 pod 的所有入站和出站流量路由到这里。此监听器把 useOriginalDst 设置为 true，这意味着它将请求交给最符合请求原始目标的监听器。如果找不到任何匹配的虚拟监听器，它会将请求发送给返回 404 的 BlackHoleCluster。\n$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr --port 15001 -o json [ { \u0026#34;name\u0026#34;: \u0026#34;virtual\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;socketAddress\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;portValue\u0026#34;: 15001 } }, \u0026#34;filterChains\u0026#34;: [ { \u0026#34;filters\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;envoy.tcp_proxy\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;cluster\u0026#34;: \u0026#34;BlackHoleCluster\u0026#34;, \u0026#34;stat_prefix\u0026#34;: \u0026#34;BlackHoleCluster\u0026#34; } } ] } ], \u0026#34;useOriginalDst\u0026#34;: true } ] 3. 我们的请求是到 9080 端口的 HTTP 出站请求，这意味着它被切换到 0.0.0.0:9080 虚拟监听器。然后，此监听器在其配置的 RDS 中查找路由配置。在这种情况下，它将查找由 Pilot 配置的 RDS 中的路由 9080（通过 ADS）。\n$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr --address 0.0.0.0 --port 9080 -o json ... \u0026#34;rds\u0026#34;: { \u0026#34;config_source\u0026#34;: { \u0026#34;ads\u0026#34;: {} }, \u0026#34;route_config_name\u0026#34;: \u0026#34;9080\u0026#34; } ... 4. 9080 路由配置仅为每个服务提供虚拟主机。我们的请求正在前往 reviews 服务，因此 Envoy 将选择我们的请求与域匹配的虚拟主机。一旦在域上匹配，Envoy 会查找与请求匹配的第一条路径。在这种情况下，我们没有任何高级路由，因此只有一条路由匹配所有内容。这条路由告诉 Envoy 将请求发送到 outbound|9080||reviews.default.svc.cluster.local 集群。\n$ istioctl proxy-config routes productpage-v1-76474f6fb7-pmglr --name 9080 -o json [ { \u0026#34;name\u0026#34;: \u0026#34;9080\u0026#34;, \u0026#34;virtualHosts\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;reviews.default.svc.cluster.local:9080\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;reviews.default.svc.cluster.local\u0026#34;, \u0026#34;reviews.default.svc.cluster.local:9080\u0026#34;, \u0026#34;reviews\u0026#34;, \u0026#34;reviews:9080\u0026#34;, \u0026#34;reviews.default.svc.cluster\u0026#34;, \u0026#34;reviews.default.svc.cluster:9080\u0026#34;, \u0026#34;reviews.default.svc\u0026#34;, \u0026#34;reviews.default.svc:9080\u0026#34;, \u0026#34;reviews.default\u0026#34;, \u0026#34;reviews.default:9080\u0026#34;, \u0026#34;172.21.152.34\u0026#34;, \u0026#34;172.21.152.34:9080\u0026#34; ], \u0026#34;routes\u0026#34;: [ { \u0026#34;match\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;/\u0026#34; }, \u0026#34;route\u0026#34;: { \u0026#34;cluster\u0026#34;: \u0026#34;outbound|9080||reviews.default.svc.cluster.local\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;0.000s\u0026#34; }, ... 5. 此集群配置为从 Pilot（通过 ADS）检索关联的端点。因此，Envoy 将使用 serviceName 字段作为密钥来查找端点列表并将请求代理到其中一个端点。\n$ istioctl proxy-config clusters productpage-v1-76474f6fb7-pmglr --fqdn reviews.default.svc.cluster.local -o json [ { \u0026#34;name\u0026#34;: \u0026#34;outbound|9080||reviews.default.svc.cluster.local\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;EDS\u0026#34;, \u0026#34;edsClusterConfig\u0026#34;: { \u0026#34;edsConfig\u0026#34;: { \u0026#34;ads\u0026#34;: {} }, \u0026#34;serviceName\u0026#34;: \u0026#34;outbound|9080||reviews.default.svc.cluster.local\u0026#34; }, \u0026#34;connectTimeout\u0026#34;: \u0026#34;1.000s\u0026#34;, \u0026#34;circuitBreakers\u0026#34;: { \u0026#34;thresholds\u0026#34;: [ {} ] } } ] 上面的整个过程就是在不创建任何规则的情况下请求从 productpage 到 reviews 的过程，从 reviews 到网格内其他应用的流量与上面类似，就不展开讨论了。接下来分析创建规则之后的请求转发过程。\n3. VirtualService 和 DestinationRule 配置解析 VirtualService 首先创建一个 VirtualService。\n$cat\u0026lt;\u0026lt;EOF|istioctlcreate-f-apiVersion:networking.istio.io/v1alpha3kind:VirtualServicemetadata:name:reviewsspec:hosts:- reviewshttp:- route:- destination:host:reviewssubset:v1EOF上一篇文章已经介绍过，VirtualService 映射的就是 Envoy 中的 Http Route Table，还是将目标锁定在 productpage 上，我们来查看一下路由配置：\n$ istioctl proxy-config routes productpage-v1-76474f6fb7-pmglr --name 9080 -o json [ { \u0026#34;name\u0026#34;: \u0026#34;9080\u0026#34;, \u0026#34;virtualHosts\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;reviews.default.svc.cluster.local:9080\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;reviews.default.svc.cluster.local\u0026#34;, \u0026#34;reviews.default.svc.cluster.local:9080\u0026#34;, \u0026#34;reviews\u0026#34;, \u0026#34;reviews:9080\u0026#34;, \u0026#34;reviews.default.svc.cluster\u0026#34;, \u0026#34;reviews.default.svc.cluster:9080\u0026#34;, \u0026#34;reviews.default.svc\u0026#34;, \u0026#34;reviews.default.svc:9080\u0026#34;, \u0026#34;reviews.default\u0026#34;, \u0026#34;reviews.default:9080\u0026#34;, \u0026#34;172.21.152.34\u0026#34;, \u0026#34;172.21.152.34:9080\u0026#34; ], \u0026#34;routes\u0026#34;: [ { \u0026#34;match\u0026#34;: { \u0026#34;prefix\u0026#34;: \u0026#34;/\u0026#34; }, \u0026#34;route\u0026#34;: { \u0026#34;cluster\u0026#34;: \u0026#34;outbound|9080|v1|reviews.default.svc.cluster.local\u0026#34;, \u0026#34;timeout\u0026#34;: \u0026#34;0.000s\u0026#34; }, ... 注意对比一下没创建 VirtualService 之前的路由，现在路由的 cluster 字段的值已经从之前的 outbound|9080|reviews.default.svc.cluster.local 变为 outbound|9080|v1|reviews.default.svc.cluster.local。\n请注意 : 我们现在还没有创建 DestinationRule！\n你可以尝试搜索一下有没有 outbound|9080|v1|reviews.default.svc.cluster.local 这个集群，如果不出意外，你将找不到 SUBSET=v1 的集群。\n由于找不到这个集群，所以该路由不可达，这就是为什么你打开 productpage 的页面会出现如下的报错：\nDestinationRule 为了使上面创建的路由可达，我们需要创建一个 DestinationRule：\n$cat\u0026lt;\u0026lt;EOF|istioctlcreate-f-apiVersion:networking.istio.io/v1alpha3kind:DestinationRulemetadata:name:reviewsspec:host:reviewssubsets:- name:v1labels:version:v1EOF其实 DestinationRule 映射到 Envoy 的配置文件中就是 Cluster。现在你应该能看到 SUBSET=v1 的 Cluster 了：\n$ istioctl proxy-config clusters productpage-v1-76474f6fb7-pmglr --fqdn reviews.default.svc.cluster.local --subset=v1 -o json [ { \u0026#34;name\u0026#34;: \u0026#34;outbound|9080|v1|reviews.default.svc.cluster.local\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;EDS\u0026#34;, \u0026#34;edsClusterConfig\u0026#34;: { \u0026#34;edsConfig\u0026#34;: { \u0026#34;ads\u0026#34;: {} }, \u0026#34;serviceName\u0026#34;: \u0026#34;outbound|9080|v1|reviews.default.svc.cluster.local\u0026#34; }, \u0026#34;connectTimeout\u0026#34;: \u0026#34;1.000s\u0026#34;, \u0026#34;circuitBreakers\u0026#34;: { \u0026#34;thresholds\u0026#34;: [ {} ] } } ] 到了这一步，一切皆明了，后面的事情就跟之前的套路一样了，具体的 Endpoint 对应打了标签 version=v1 的 Pod：\n$ kubectl get pod -l app=reviews,version=v1 -o wide NAME READY STATUS RESTARTS AGE IP NODE reviews-v1-5b487cc689-njx5t 2/2 Running 0 11h 172.30.104.38 192.168.123.248 $ curl http://$PILOT_SVC_IP:8080/debug/edsz|grep \u0026#34;outbound|9080|v1|reviews.default.svc.cluster.local\u0026#34; -A 27 -B 2 { \u0026#34;clusterName\u0026#34;: \u0026#34;outbound|9080|v1|reviews.default.svc.cluster.local\u0026#34;, \u0026#34;endpoints\u0026#34;: [ { \u0026#34;lbEndpoints\u0026#34;: [ { \u0026#34;endpoint\u0026#34;: { \u0026#34;address\u0026#34;: { \u0026#34;socketAddress\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;172.30.104.38\u0026#34;, \u0026#34;portValue\u0026#34;: 9080 } } }, \u0026#34;metadata\u0026#34;: { \u0026#34;filterMetadata\u0026#34;: { \u0026#34;istio\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;kubernetes://reviews-v1-5b487cc689-njx5t.default\u0026#34; } } } } ] } ] }, 现在再次用浏览器访问 productpage，你会发现报错已经消失了。\n4. 参考  调试 Envoy 和 Pilot  ","description":"","id":3,"section":"posts","tags":["istio","service mesh","kubernetes"],"title":"数据包在 Istio 网格中的生命周期（下）","uri":"https://SJiaman.github.io/posts/where-is-the-request-2/"},{"content":"为了循序渐进，先从二维开始讲起，然后过渡到三维\n1. 二维空间 我们从一个五边形的面积开始说起\n比如我们要求这个正五边形的面积，该怎样用向量求呢？\n先简化这个问题，不用考虑五边形，只需考虑三角形。\n现在，我们把正五边形分割成三个三角形，再把三角形的面积加起来，就得到了五边形的面积。\n那么问题来了 :** 怎样求三角形的面积？**\n设三角形的面积为S，那么\n\r$$\rS = \\frac{1}{2}\\left|\\vec{A}\\right|\\left|\\vec{MN}\\right| = \\frac{1}{2}\\left|\\vec{A}\\right|\\left|\\vec{B}\\right|\\sin(\\theta) \\tag{1}\r$$\r$\\sin(\\theta)$ 该如何求呢？\n如果你学过向量的点积，应该知道$\\vec{a}\\cdot\\vec{b}=\\left|\\vec{a}\\right|\\left|\\vec{b}\\right|\\cos(\\theta)$.\n所以为了求$\\sin(\\theta)$，我们可以先求出$\\cos(\\theta)$\n\r$$\r\\cos(\\theta)=\\frac{\\vec{a}\\cdot\\vec{b}}{\\left|\\vec{a}\\right|\\left|\\vec{b}\\right|} \\tag{2}\r$$\r再利用公式\n\r$$\r\\cos^2(\\theta)+\\sin^2(\\theta)=1 \\tag{3}\r$$\r便可以求出 $\\sin(\\theta)$ 的值。\n通过以上步骤，可以看出这样做很麻烦，有没有更简单的办法呢？当然有\n求 $\\sin(\\theta)$ 太麻烦了，但是求 $\\cos(\\theta)$ 却很简单，为了避免求 $\\sin(\\theta)$，我们能否找到一个角，使这个角的余弦等于 $\\sin(\\theta)$ ?\n作向量$\\vec{A}$、$\\vec{B}$，夹角记为$\\theta$，将向量$\\vec{A}$逆时针旋转 $90^\\circ$ 得到 $\\vec{A^\\prime}$，如下图所示：\n通过上图给的条件，我们已知：\n\r$$\r\\begin{cases}\r\\beta=\\frac{\\pi}{2}-\\theta \\\\ \\cos(\\beta)=\\sin(\\theta)\r\\end{cases}\r$$\r这意味着$\\vec{A}$的模长乘以$\\vec{B}$的模长，再乘以$\\sin(\\theta)$，等于$\\vec{A^\\prime}$的模长乘以$\\vec{B}$的模长，再乘以$\\cos(\\beta)$，得到：\n\r$$\r\\begin{aligned}\r\u0026\\left|\\vec{A}\\right|\\left|\\vec{B}\\right|\\sin(\\theta) \\\\\r= \u0026\\left|\\vec{A^\\prime}\\right|\\left|\\vec{B}\\right|\\cos(\\beta) \\\\\r= \u0026\\vec{A^\\prime}\\cdot\\vec{B}\r\\end{aligned}\r$$\r即：\n\r$$\r\\left|\\vec{A}\\right|\\left|\\vec{B}\\right|\\sin(\\theta)=\\vec{A^\\prime}\\cdot\\vec{B} \\tag{4}\r$$\r这个方法看起来不错，不过还有一点是不知道的，就是怎么求$\\vec{A^\\prime}$呢?\n假设$\\vec{A}$的坐标为$\\left\\langle a_1,a_2 \\right\\rangle$，由我画的图可知，逆时针旋转 $90^\\circ$ 后，得到：$A^\\prime=\\left\\langle -a_2,a_1 \\right\\rangle$ 。\n同时再假设$\\vec{B}$的坐标为$\\left\\langle b_1,b_2 \\right\\rangle$，现在将$\\vec{A}$和$\\vec{B}$的坐标分别带入(4)式，得到：\n\r$$\r\\begin{aligned}\r\u0026 \\vec{A^\\prime}\\cdot\\vec{B} \\\\\r= \u0026 \\left\\langle -a_2,a_1 \\right\\rangle \\cdot \\left\\langle b_1,b_2 \\right\\rangle \\\\\r= \u0026 a_1b_2-a_2b_1\r\\end{aligned}\r$$\r如果你学过行列式，应该知道\n\r$$\r\\begin{aligned}\r\u0026 a_1b_2-a_2b_1 \\\\\r= \u0026 \\begin{vmatrix} a_1 \u0026 a_2 \\\\\\ b_1 \u0026 b_2 \\end{vmatrix} \\\\\r= \u0026 det(\\vec{A},\\vec{B})\r\\end{aligned}\r$$\r由此可知，三角形的面积\n\r$$\rS=\\frac{1}{2}det(\\vec{A},\\vec{B}) \\tag{5}\r$$\r现在可以得出结论：\n 向量$\\vec{A}$与向量$\\vec{B}$的行列式表示一个以$\\vec{A}$和$\\vec{B}$为边构成的平行四边形的面积\n 还可以表述得更严格一点，因为面积没有负数，而行列式的值有正有负，符号取决于两个向量之间的夹角，所以我们可以这样描述：\n 向量$\\vec{A}$与向量$\\vec{B}$的行列式的绝对值表示一个以$\\vec{A}$和$\\vec{B}$为边构成的平行四边形的面积\n 2. 三维空间 在空间中，从简单的开始，我们可以做两件事情：\n 求平行六面体的体积 求平行六面体的表面积  咱们先来求平行六面体的体积。\n平行六面体的体积 求体积之前，需要了解几个定义\n空间中的行列式 空间中也有行列式的概念，假设有三个向量$\\vec{A}$、$\\vec{B}$和$\\vec{C}$，定义：\n\r$$\r\\begin{aligned}\rdet(\\vec{A},\\vec{B},\\vec{C}) \u0026 = \\begin{vmatrix} a_1 \u0026 a_2 \u0026 a_3 \\\\\\ b_1 \u0026 b_2 \u0026 b_3 \\\\\\ c_1 \u0026 c_2 \u0026 c_3 \\end{vmatrix} \\\\\r\u0026 = a_1\\begin{vmatrix} b_2 \u0026 b_3 \\\\\\ c_2 \u0026 c_3 \\end{vmatrix} - a_2\\begin{vmatrix} b_1 \u0026 b_3 \\\\\\ c_1 \u0026 c_3 \\end{vmatrix} + a_3\\begin{vmatrix} b_1 \u0026 b_2 \\\\\\ c_1 \u0026 c_2 \\end{vmatrix}\r\\end{aligned}\r$$\r如果你学过行列式的知识，上面的计算过程应该很容易理解，我就不作过多解释了。\n叉乘 叉乘适用于两个在空间内的向量（这里我指的是三维空间），定义：\n\r$$\r\\begin{aligned}\r\\vec{A}\\times\\vec{B}=\\begin{vmatrix} \\hat{i} \u0026 \\hat{j} \u0026 \\hat{k} \\\\\\ a_1 \u0026 a_2 \u0026 a_3 \\\\\\ b_1 \u0026 b_2 \u0026 b_3 \\end{vmatrix} \\end{aligned}\r$$\r其中，$\\hat{i}$,$\\hat{j}$,$\\hat{k}$分别为三维空间中的三个坐标轴上的单位向量。\n我们把$\\vec{A}\\times\\vec{B}$称为向量$\\vec{A}$与$\\vec{B}$的$\\color{blue}{叉乘！}$\n如果你仔细观察，你会发现，这个行列式的第二行和第三行分别是向量$\\vec{A}$和$\\vec{B}$的坐标，但是第一行却是三个单位向量，这意味着后面两行的元素都是数值，而第一行的元素都是向量。这意味着什么？这不是常理上的行列式，如果你尝试在计算器中这样计算，它会显示这是错误的，向量不该出现在这里。\n那么，为什么要这么做呢？\n如果使用上面提到的空间中的行列式的定义，可以得到：\n\r$$\r\\begin{vmatrix} \\hat{i} \u0026 \\hat{j} \u0026 \\hat{k} \\\\ a_1 \u0026 a_2 \u0026 a_3 \\\\ b_1 \u0026 b_2 \u0026 b_3 \\end{vmatrix}\r= \\begin{vmatrix} a_2 \u0026 a_3 \\\\ b_2 \u0026 b_3 \\end{vmatrix}\\hat{i}\r- \\begin{vmatrix} a_1 \u0026 a_3 \\\\ b_1 \u0026 b_3 \\end{vmatrix}\\hat{j}\r+ \\begin{vmatrix} a_1 \u0026 a_2 \\\\ b_1 \u0026 b_2 \\end{vmatrix}\\hat{k} \\tag{6}\r$$\r你发现了什么？没错，我们得到的结果不是一个数，而是一个$\\color{blue}{向量}$，这就是向量叉乘的定义。\n那么问题在于，这样定义有什么好处呢？这种怪异计算的几何意义在哪里？为什么我们要费心去这样做？\n下面我们对上面的式子进行转化，看看会出现什么神奇的结果。\n将式(6)进一步化简，得到：\n\r$$\r\\begin{aligned}\r\\vec{A}\\times\\vec{B}=(a_2b_3-a_3b_2)\\hat{i}-(a_1b_3-a_3b_1)\\hat{j}+(a_1b_2-a_2b_1)\\hat{k}\r\\end{aligned}\r$$\r看起来没什么特别的，试着求一下$\\vec{A}\\times\\vec{B}$的模，为了方便计算，我们求$\\vec{A}\\times\\vec{B}$的模的平方\n\r$$\r\\begin{aligned}\r\\left| \\vec{A}\\times\\vec{B} \\right|^2 \u0026 = (a_2b_3-a_3b_2)^2 + (a_1b_3-a_3b_1)^2 + (a_1b_2-a_2b_1)^2 \\\\\r\u0026 = (a_1^2b_2^2+a_1^2b_3^2) + (a_2^2b_1^2+a_2^2b_3^2) + (a_3^2b_1^2+a_3^2b_2^2) \\\\\r\u0026 - 2(a_1a_2b_1b_2+a_1a_3b_1b_3+a_2a_3b_2b_3) \\\\ \u0026 = (\\underbrace{a_1^2b_2^2+a_1^2b_3^2}+a_1^2b_1^2) + (\\underbrace{a_2^2b_1^2+a_2^2b_3^2}+a_2^2b_2^2) + (\\underbrace{a_3^2b_1^2+a_3^2b_2^2}+a_3^2b_3^2)i - (a_1^2b_1^2+a_2^2b_2^2+a_3^2b_3^2) - 2(a_1a_2b_1b_2+a_1a_3b_1b_3+a_2a_3b_2b_3) \\\\\r\u0026 = {(\\underbrace{a_1^2b_1^2+a_1^2b_2^2+a_1^2b_3^2) + (a_2^2b_1^2+a_2^2b_2^2+a_2^2b_3^2) + (a_3^2b_1^2+a_3^2b_2^2+a_3^2b_3^2)}} - {\\underbrace{(a_1^2b_1^2+a_2^2b_2^2+a_3^2b_3^2) + 2(a_1a_2b_1b_2+a_1a_3b_1b_3+a_2a_3b_2b_3)}} \\\\\r\u0026 = (a_1^2+a_2^2+a_3^2)(b_1^2+b_2^2+b_3^2) - (a_1b_1+a_2b_2+a_3b_3)^2 \\\\\r\u0026 = \\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2-\\left|\\vec{A}\\cdot\\vec{B}\\right|^2 \\\\\r\u0026 = \\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2\\cdot1-\\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2\\cdot\\frac{\\left|\\vec{A}\\cdot\\vec{B}\\right|^2}{\\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2} \\\\\r\u0026 = \\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2(1-\\frac{\\left|\\vec{A}\\cdot\\vec{B}\\right|^2}{\\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2}) \\\\\r\u0026 = \\left|\\vec{A}\\right|^2\\cdot\\left|\\vec{B}\\right|^2(1-cos^2\\left\\langle\\vec{A},\\vec{B}\\right\\rangle) \\\\\r\u0026 = (\\left|\\vec{A}\\right|\\cdot\\left|\\vec{B}\\right|\\cdot\\sin\\left\\langle\\vec{A},\\vec{B}\\right\\rangle)^2\r\\end{aligned}\r$$\r发现了什么？原来$\\vec{A}\\times\\vec{B}$的模长等于一个以$\\vec{A}$和$\\vec{B}$为边构成的平行四边形的面积。\n接下来的问题是：既然$\\vec{A}\\times\\vec{B}$的结果是一个向量，那么这个向量的方向是什么呢？\n答案是：它的方向垂直于向量$\\vec{A}$与$\\vec{B}$构成的平面，并且遵循右手定则。\n如果你不知道右手定则，我可以解释一下：\n 首先，你的右手平行于向量 $\\vec{A}$ 的方向，然后，你的手指向向量 $\\vec{B}$ 的方向弯曲，这时，你的大拇指竖直的方向就是 $\\vec{A}\\times\\vec{B}$ 的方向。\n 下面我们来证明一下为什么$\\vec{A}\\times\\vec{B}$的方向垂直于向量$\\vec{A}$与$\\vec{B}$构成的平面。\n为了简化，令\n\r$$\r\\begin{cases}\rm_1=a_2b_3-a_3b_2 \\\\\rm_2=a_1b_3-a_3b_1 \\\\\rm_3=a_1b_2-a_2b_1\r\\end{cases}\r$$\r于是可以得到\n\r$$\r\\vec{A}\\times\\vec{B}=m_1\\hat{i}-m_2\\hat{j}+m_3\\hat{k} \\tag{7}\r$$\r基本思路是这样 :** 我们从$\\vec{A}$与$\\vec{B}$构成的平面中找两个方向不在同一条直线上的向量，如果$\\vec{A}\\times\\vec{B}$与这两个向量均垂直,那么它就垂直于$\\vec{A}$与$\\vec{B}$构成的平面**\n为了方便计算，我们这样定义三个互相垂直的单位向量：其中，向量$\\hat{i}$与$\\hat{j}$在$\\vec{A}$与$\\vec{B}$构成的平面上，而向量$\\hat{k}$垂直于这个平面。\n现在问题简单了，只要我们能证明$\\hat{i}\\times\\hat{j}$的方向平行于$\\hat{k}$，就说明$\\vec{A}\\times\\vec{B}$的方向垂直于向量$\\vec{A}$与$\\vec{B}$构成的平面。\n设 $\\hat{i}=\\left\\langle1,0,0\\right\\rangle$,$\\hat{j}=\\left\\langle0,1,0\\right\\rangle$,$\\hat{k}=\\left\\langle0,0,1\\right\\rangle$，那么\n\r$$\r\\begin{aligned}\r\\hat{i}\\times\\hat{j} \u0026 = \\begin{vmatrix} \\hat{i} \u0026 \\hat{j} \u0026 \\hat{k} \\\\ 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\end{vmatrix} \\\\\r\u0026 = \\begin{vmatrix} 0 \u0026 0 \\\\ 1 \u0026 0 \\end{vmatrix}\\hat{i}-\\begin{vmatrix} 1 \u0026 0 \\\\ 0 \u0026 0 \\end{vmatrix}\\hat{j}+\\begin{vmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{vmatrix}\\hat{k} \\\\\r\u0026 = \\hat{k}\r\\end{aligned}\r$$\r太神奇了，$\\hat{i}\\times\\hat{j}$竟然等于$\\hat{k}$，所以当然也平行于$\\hat{k}$，所以$\\vec{A}\\times\\vec{B}$的方向垂直于向量$\\vec{A}$与$\\vec{B}$构成的平面，并且遵循右手定则。\n于是可以得到如下的结论：\n $\\left|\\vec{A}\\times\\vec{B}\\right|$等于一个以$\\vec{A}$和$\\vec{B}$为边构成的平行四边形的面积 $\\vec{A}\\times\\vec{B}$的方向垂直于向量$\\vec{A}$与$\\vec{B}$构成的平面，并且遵循右手定则  下面我们回到最初提出的问题 :** 求平行六面体的体积**\n如上图所示，我们要求由三个向量 $\\vec{A}$,$\\vec{B}$ 与 $\\vec{C}$ 构成的平行六面体的体积。\n设体积为V，向量$\\vec{A}$与$\\vec{B}$构成的平行四边形的面积为S，高为h，那么：\n\r$$\rV=S \\cdot h \\tag{8}\r$$\r通过上面的分析，可以得知$S=\\left|\\vec{A}\\times\\vec{B}\\right|$，那么高度h该怎么求呢？\n假设高度h的方向为$\\vec{H}$，那么h等于向量$\\vec{C}$在向量$\\vec{H}$上的投影，所以\n\r$$\r\\begin{aligned}\rh \u0026 = \\left|\\vec{C}\\cdot\\right|\\cos\\left\\langle\\vec{C},\\vec{H}\\right\\rangle \\\\\r\u0026 = \\left|\\vec{C}\\right|\\cdot\\frac{\\vec{C}\\cdot\\vec{H}}{\\left|\\vec{C}\\right|\\left|\\vec{H}\\right|} \\\\\r\u0026 = \\vec{C}\\cdot\\frac{\\vec{H}}{\\left|\\vec{H}\\right|} \\\\\r\u0026 = \\vec{C}\\cdot\\vec{h}, \u0026 \\text{设$\\vec{h}$为向量$\\vec{H}$方向上的单位向量}\r\\end{aligned}\r$$\r带入(8)式，得：\n\r$$\r\\begin{aligned}\rV \u0026 = \\left|\\vec{A}\\times\\vec{B}\\right|\\cdot(\\vec{C}\\cdot\\vec{h}) \\\\\r\u0026 = \\left|\\vec{A}\\times\\vec{B}\\right|\\cdot(\\vec{C}\\cdot\\frac{\\vec{A}\\times\\vec{B}}{\\left|\\vec{A}\\times\\vec{B}\\right|}) \\\\\r\u0026 = \\vec{C}\\cdot(\\vec{A}\\times\\vec{B}) \\\\\r\u0026 = \\left\\langle c_1,c_2,c_3 \\right\\rangle\\cdot\\lbrace(a_2b_3-a_3b_2)\\hat{i} - (a_1b_3-a_3b_1)\\hat{j} + (a_1b_2-a_2b_1)\\hat{k}\\rbrace \\\\\r\u0026 = \\left\\langle c_1,c_2,c_3 \\right\\rangle\\cdot\\left\\langle a_2b_3-a_3b_2,a_1b_3-a_3b_1,a_1b_2-a_2b_1 \\right\\rangle \\\\\r\u0026 = c_1\\begin{vmatrix} a_2 \u0026 a_3 \\\\ b_2 \u0026 b_3 \\end{vmatrix} - c_2\\begin{vmatrix} a_1 \u0026 a_3 \\\\ b_1 \u0026 b_3 \\end{vmatrix} + c_3\\begin{vmatrix} a_1 \u0026 a_2 \\\\ b_1 \u0026 b_2 \\end{vmatrix} \\\\\r\u0026 = det(\\vec{A},\\vec{B},\\vec{C})\r\\end{aligned}\r$$\r即：\n\r$$\rV=det(\\vec{A},\\vec{B},\\vec{C})=\\vec{C}\\cdot(\\vec{A}\\times\\vec{B}) \\tag{9}\r$$\r$\\vec{C}\\cdot(\\vec{A}\\times\\vec{B})$ 称为向量的$\\color{blue}{混合积}$。\n现在可以得出结论：\n 向量$\\vec{A}$、$\\vec{B}$与$\\vec{C}$的行列式等于由向量$\\vec{A}$、$\\vec{B}$与$\\vec{C}$构成的平行六面体的体积\n 体积的部分暂时就讲到这里，接下来的一篇将会介绍平行六面体的面积。\n","description":"","id":4,"section":"posts","tags":["math"],"title":"向量的叉乘与行列式","uri":"https://SJiaman.github.io/posts/%E5%90%91%E9%87%8F%E7%9A%84%E5%8F%89%E4%B9%98%E4%B8%8E%E8%A1%8C%E5%88%97%E5%BC%8F/"},{"content":"为了弄明白子空间投影是怎么一回事，我们遵循从低维到高维的规律，先从二维开始讲起。\n1. 二维空间 如下图所示（我随手画的，不要介意），设向量p是向量b在向量a上面的投影，向量e垂直于向量p及a。\n于是我们可以得到这样的一个等式：\n$$ a^Te = 0 $$\n即\n$$a^T(b-xa) = 0\\tag{1}$$\n解得：\n$$x = \\frac{a^Tb}{a^Ta}$$\n于是向量p可表示为：\n$$p = xa = a\\frac{a^Tb}{a^Ta}\\tag{2}$$\n现在我们设\n$$p = Pb\\tag{3}$$\n我们把这个矩阵P称为$\\color{red}{投影矩阵}$。\n比较式(2)和式(3)，立即可以知道：\n$$\\color{red}{P = \\frac{a \\cdot a^T}{a^T \\cdot a}}\\tag{4}$$\n2. 三维空间 为了让你们能够有一个直观的认识，我仍然用我高超的画艺画了一幅美图：\n假设图中的那个平面由向量$a_1$和$a_2$构成，令\n$$A = \\begin{bmatrix} a_1 \u0026amp; a_2 \\end{bmatrix}$$\n由于向量p在平面上，所以p可以表示为：\n$$p = \\hat{x_1}a_1 + \\hat{x_2}a_2\\tag{5}$$\n即\n$$p = A\\hat{x}\\tag{6}$$\n与二维空间类似，设向量p是向量b在平面上的投影，向量e垂直于那个平面，当然也垂直于向量p，同样也垂直于向量$a_1$和$a_2$,于是可以得到方程组：\n\r$$\r\\begin{cases}\ra_1^T(b - A\\hat{x}) = 0 \\\\\ra_2^T(b - A\\hat{x}) = 0 \\\\\r\\end{cases}\\tag{7}\r$$\r即\n\r$$\r\\begin{bmatrix} a_1^T \\\\a_2^T \\end{bmatrix}(b - A\\hat{x}) = \\begin{bmatrix} 0 \\\\0 \\end{bmatrix}\r$$\r进一步化简得到：\n$$A^T(b - A\\hat{x}) = 0\\tag{8}$$\n解得：\n$$\\hat{x} = (A^TA)^{-1}(A^Tb)\\tag{9}$$\n将(9)代入(6)得：\n$$p = A\\hat{x} = A(A^TA)^{-1}A^Tb\\tag{10}$$\n与二维空间类似，我们设\n$$p = Pb\\tag{11}$$\n比较式(10)和式(11)，立即可以得到：\n$$\\color{red}{P = A(A^TA)^{-1}A^T}\\tag{12}$$\n这就是投影矩阵的表达式！\n","description":"","id":5,"section":"posts","tags":["math"],"title":"子空间投影","uri":"https://SJiaman.github.io/posts/%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/"},{"content":"曾经看过国内各种关于讲解最小二乘法的教科书，但都是一大堆枯燥的推导公式，看起来很高深的样子，其实根本不知道它在说些什么！传授知识本来就应该告诉你这个东西到底是什么，它到底是干嘛的，就应该把复杂的问题简单化，可国内大多数教科书都是反其道而行，全是看起来很牛逼的样子，学生看了却什么也不懂。今天我就用最通俗易懂的方式，从线性代数和线性空间的角度告诉你什么是最小二乘法。\n最小二乘法是一种最优化技术，它的做法是找到一组估计值，使得估计值与实际值的平方和的值最小，通过使误差的平方和最小，我们可以得到一下线性方程组，对这个线性方程组进行求解就可以得到拟合曲线。我们可以通过一个例子来进行讲解。\n假设有一组数据点$t_1$，$t_2$和$t_3$，它们的坐标分别是(1，1)，(2，2)，(3，2)，而我想找到最优的那条线，假设这条直线为：\n$$y = C + Dt\\tag{1}$$\n它不会通过所有的点，因为不存在这样的直线，所以我要选一条最优的使总误差最小的直线。我们需要知道总误差怎么度量，因为它决定了哪条线胜出，我们必须先定出误差是什么，才能通过最小化这个量而找到C和D。在此我就不作图了，因为图像很简单，你们可以自己想象一下，或者自己拿笔画画。\n将这三个点带入方程，得到：\n\r$$\r\\begin{cases}\rC + D = 1 \\\\\rC + 2D =2 \\\\\rC + 3D =2\r\\end{cases}\\tag{2}\r$$\r通过计算我们知道，它们联立是无解的，但可以有最优解。\n这个方程组可写成矩阵的形式\n$$AX = B\\tag{3}$$\n其中，$A = \\begin{bmatrix} 1 \u0026amp; 1 \\\\1 \u0026amp; 2 \\\\1 \u0026amp; 3 \\end{bmatrix}$，$X = \\begin{bmatrix} C \u0026amp; D \\end{bmatrix}$，$B = \\begin{bmatrix} 1 \\\\2 \\\\3 \\end{bmatrix}$。\n A的列向量线性无关，所以它们构成了列空间的一组基，但列空间不包括向量B，所以方程无解。那么最优解是什么呢？\n我们将AX与B之间的差值相加，得到：\n$$AX - B = E\\tag{4}$$\n其中，$E = \\begin{bmatrix} e_1 \\\\e_2 \\\\e_3 \\end{bmatrix}$，$e_1 = C + D - 1$，$e_2 = C + 2D - 2$，$e_3 = C + 3D - 2$，E称为误差向量。\n我们要求的是$\\left|AX - B\\right|^2$ = $\\left|E\\right|^2$的最小值。\n$$\\left|E\\right|^2 = \\left|e_1\\right|^2 + \\left|e_2\\right|^2 + \\left|e_3\\right|^2\\tag{5}$$\n分别过点$t_1$,$t_2$和$t_3$作与x轴垂直的直线，与直线y=C+Dt的交点分别为$s_1$,$s_2$,$s_3$。于是\n\r$$\r\\begin{cases}\r\\left|e_1\\right| = \\left|t_1-s_1\\right| \\\\\r\\left|e_2\\right| = \\left|t_2-s_2\\right| \\\\\r\\left|e_3\\right| = \\left|t_3-s_3\\right|\r\\end{cases}\\tag{6}\r$$\r假设$s_1$,$s_2$,$s_3$的纵坐标分别为$p_1$,$p_2$,$p_3$，令$p = \\begin{bmatrix}p_1 \\\\p_2\\\\p_3\\end{bmatrix}$。\n我们知道方程组$AX = B$是无解的，但方程组$AX = p$有解，我们来求解方程组$AX = p$。为了提醒自己这里表示的是最优的估计，而不是完美的结果，我们在X上面加个小帽子，使方程组变为\n$$A\\hat{X} = p\\tag{7}$$\n其中p是B在p向量这个方向上的投影，设投影矩阵为P，则\n$$p = PB\\tag{8}$$\n如果不懂什么是投影矩阵，可以参考我的另一篇文章子空间投影，在此不作赘述。\n通过投影矩阵的知识我们知道投影矩阵P的表达式为\n$$P = A(A^TA)^{-1}A^T\\tag{9}$$\n代入(8)，得：\n$$p = A(A^TA)^{-1}A^TB\\tag{10}$$\n将(10)代入(7)，得：\n$$A\\hat{X} = A(A^TA)^{-1}A^TB$$\n最后得到方程组为：\n$$A^TAX = A^TB\\tag{11}$$\n解得\n$$\\hat{X} = \\begin{bmatrix} \\frac{2}{3} \\\\ \\frac{1}{2} \\end{bmatrix}$$\n这就是最优解，所以最优的那条直线为：\n$$y = \\frac{2}{3} + \\frac{1}{2}t\\tag{12}$$\n","description":"","id":6,"section":"posts","tags":["math"],"title":"最小二乘法的本质","uri":"https://SJiaman.github.io/posts/%E5%8D%81%E5%88%86%E9%92%9F%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/"},{"content":"一只特立独行的猴子\r笔名世今\r热爱生活\r迷恋诗和远方\r努力拼搏，坚持不懈\r极简主义者\r","description":"博主的个人简介","id":7,"section":"","tags":null,"title":"关于博主","uri":"https://SJiaman.github.io/about/"}]